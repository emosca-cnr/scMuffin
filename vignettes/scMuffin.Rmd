---
title: "scMuffin package vignettes"
package: scMuffin
bibliography: references.bib
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{scMuffin package vignettes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---


![](images/logo.jpg){width=300px}

# Installation

scMuffin requires R >= 4.0.0, due to some of its dependencies, like Seurat [@Hao2021]. R can be installed from CRAN at the URL https://cran.r-project.org/index.html.

To succesfully install scMuffin you need some packages from Bioconductor (https://bioconductor.org) and github (https://github.com/). These packages can be installed using the following commands:

```{r, include=TRUE, eval=FALSE}
if (!require("BiocManager", quietly = TRUE)){
  install.packages("BiocManager")
}
BiocManager::install(c("BiocStyle", "ComplexHeatmap", "DESeq2", "org.Hs.eg.db"))

if (!require("devtools", quietly = TRUE)){
  install.packages("devtools")
}
devtools::install_github("theislab/destiny")
```

The other dependencies, if missing, should be automatically installed using the following command:

```{r, include=TRUE, eval=FALSE}
devtools::install_github("emosca-cnr/scMuffin", build_vignettes = TRUE)
```

To load the package:

```{r, include=TRUE, eval=FALSE}
library(scMuffin)
```

```{r, include=F, message=FALSE, warning=FALSE, eval=T}
devtools::load_all("~/source/general/single_cell/scMuffin")
```

# Input

scMuffin is intended to be used downstream general purpose tasks like quality control, normalization, cell clustering and dataset integration, for which there are dedicated tools, such as Seurat [@Hao2021]. scMuffin requires three inputs:

* genes-by-cells raw counts matrix;
* genes-by-cells normalized expression matrix;
* a partition of cells (cell clusters).

Typically, the two genes-by-cells matrices have already been filtered to exclude low quality cells and genes that could negatively affect the analyses. However, the characterization of cells that can be achieved with scMuffin offers insights that can be used to (further) filter a dataset and/or to decide on which cells apply particular analyses (e.g. biomarker identification). In general, according to research questions and experimental design one may want to apply strong or mild filters before using scMuffin.

# Obtaining the data used in this vignette
To run the examples included in this vignette you need the following data:

* two single cell datasets with counts as well as normalized expression values;
* cell clusters;
* UMAP visualization;
* cluster markers.

Here's an example of how these data can be obtained from a publicly available study on High-Grade Glioma [@Yuan2018] (GSE103224):

1. download the filtered genes-by-cells mtrices from the URLs:

* sample PJ016: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM2758471;
* sample PJ017: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM2758472.

2. read the text files into R and use the Seurat package [@Hao2021] to perform a series of typical tasks (e.g. normalization, clustering); here's a concise example using sample PJ016:
```{r, include=TRUE, eval=FALSE}
gbc_counts <- read.table("GSM2758471_PJ016.filtered.matrix.txt")
sym <- gbc_counts[, "V2"]
gbc_counts[, "V2"] <- NULL
gbc_counts <- keep_strongest_representative(gbc_counts, sym)
seu_obj_1 <- CreateSeuratObject(count=gbc_counts, project="PJ016")
seu_obj_1 <- NormalizeData(seu_obj_1)
seu_obj_1 <- FindVariableFeatures(seu_obj_1)
seu_obj_1 <- ScaleData(seu_obj_1)
seu_obj_1 <- RunPCA(seu_obj_1)
seu_obj_1 <- FindNeighbors(seu_obj_1)
seu_obj_1 <- FindClusters(seu_obj_1)
seu_obj_1 <- RunUMAP(seu_obj_1)
```
The genes-by-cells count matrix available at NCBI GEO is provided with Ensembl identifiers and gene symbols, which are not unique. So, after having read the table, we take advantage of the function `keep_strongest_representative`, which defines a genes-by-cells matrix with symbols as row names. In case of multiple Ensembl ids mapped to the same symbol, the row with the highest average count is kept as representative of the gene. In a real scenario, the functions listed above should be run using appropriate parameters that take into account the specificities of the dataset under consideration and the objectives of the analysis that one wants to perform. Here we just wanted to provide a means to obtain a dataset to follow this vignette. Please read the Seurat documentation for further details about the functions listed above.

# The scMuffinList data structure
All data and results of scMuffin are stored in the scMuffinList, so that every function takes in input such structure and returns a modified version of it. The scMuffinList can be created as follows:
```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- create_scMuffinList(counts=GetAssayData(seu_obj_1, assay="RNA", slot="counts"), normalized=GetAssayData(seu_obj_1, assay="RNA", slot="data"))
```
Many analyses require cell clusters. Any partition can be added as follows:
```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- add_partitions(scMuffinList_demo, clusters = seu_obj_1$seurat_clusters, partition_id = "global_expr")
```
where seu_obj_1$seurat_clusters is a named vector that contains cells clusters and whose names are cell labels. 
```{r, include=T, eval=T, echo=T}
head(scMuffinList_demo$partitions[, 2, drop=F])
```

# Gene set scoring

scMuffin provides functions to set up one or more collections of gene sets and perform cell-level estimation of gene set expression in relation to an empirical null model. This can be applied to any gene set, and can therefore be used to estimate various cellâ€™s phenotypes, like pathway activities or marker set expression.

## Assembling input gene sets

The function `prepare_gsls` retrieves gene sets from CellMarker [Zhang2019], PanglaoDB [@Franzen2019], CancerSEA [@Yuan2019] and MSigDB [@Subramanian2005], and accepts custom gene set as well. The full list of gene sets available whitin CellMarker, PanglaoDB and CancerSEA collections can be listed using:
```{r, include=TRUE, eval=FALSE}
data("gsls_EntrezID")
data("gsls_Symbol")
```

while in the case of MSigDB we can use its dedicated functions:

```{r, include=TRUE, eval=FALSE}
msigdbr::msigdbr_collections()
msigdbr::msigdbr_species()
```

The gene sets of interest can be selected acting on the corresponding arguments `CM_tissues`, `PNDB_tissues`, and `msigdb_hs_cat_subcat`. In the case of CellMarker and PanglaoDB we can specify a list of desired tissues. The full set can be listed by means of show_tissues. Here we show just the first part of the output:
```{r, include=TRUE, eval=FALSE}
head(show_tissues())
```

Here is an example:
```{r, include=TRUE, eval=FALSE}
gsc <- prepare_gsls(gs_sources = c("CancerSEA", "PNDB"), PNDB_tissues = c("Brain"), scMuffinList = scMuffinList_demo, genes_min = 3)
```

Note that in the case of MSigDB we have to set up a `data.frame` to specify species, category and sub_category of the gene set collections.

## Calculate Gene set scores at cell and cluster level

In the following example, we estimate the scores for CancerSEA gene sets:

```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- calculate_gs_scores(scMuffinList = scMuffinList_demo, gs_list = gsc$CancerSEA)
```
The results of any analysis are stored as elements of the `scMuffinList`. The gene set scoring engine stores its results in `scMuffinList$gene_set_scoring`, where `summary` is a cells-by-features data.frame with cell scores, and `full` contains a series of additional details for every gene set:
```{r, include=TRUE, eval=TRUE}
head(scMuffinList_demo$gene_set_scoring$summary)
head(scMuffinList_demo$gene_set_scoring$full$CSEA_Angiogenesis)
```

The function `calculate_gs_scores_in_clusters` defines the median values of gene set scores in every cluster of a given partition id:
```{r, include=TRUE, eval=FALSE}
scMuffinList <- calculate_gs_scores_in_clusters(scMuffinList, partition_id = "global_expr")
```
```{r, include=TRUE, eval=TRUE}
scMuffinList_demo$cluster_data$global_expr$gene_set_scoring$summary
```

These mean values are useful to obtain a concise visualization of gene set expression throughout the dataset, using the function `plot_heatmap_features_by_clusters`:
```{r, include=TRUE, eval=FALSE}
plot_heatmap_features_by_clusters(scMuffinList, feature_source = "gss")
```
![caption](images/gene_set_scores_clusters.png){width=600px} 

# CNV inference

## CNV calculation
CNV inference is performed by the function `CNV_analysis`.

```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- CNV_analysis(scMuffinList_demo)
```
The results are stored in `scMuffinList_demo$CNV`, where summary contains the "CNV_signal" and `scMuffinList_demo$CNV$full$CNV` the regions-by-cells CNV matrix; the element `scMuffinList_demo$CNV$full$regions2genes` is important to map the original data into the CNV regions; lastly, the `scMuffinList_demo$CNV$full$detected_cnv_regions` is a data.frame that list the CNV regions detected in each chromosome and cell cluster:
```{r, include=TRUE, eval=TRUE}
head(scMuffinList_demo$CNV$summary)
head(scMuffinList_demo$CNV$full$CNV)
head(scMuffinList_demo$CNV$full$regions2genes)
head(scMuffinList_demo$CNV$full$detected_cnv_regions$chr1)
```
Importantly, CNV inference adds the "CNV" partition:
```{r, include=TRUE, eval=TRUE}
head(scMuffinList_demo$partitions)
```

The calculation can be demanding. For example, it requires approximately 10 minutes on 2 cores (dual Intel(R) Xeon(R), 2.60GHz). 

## CNV visualization

scMuffin provides two visualizations for CNVs: an heatmap and the cluster average profile plot. The heatmap is based on ComnplexHeatmap package and beside it, it is possible to visualize the genomic location of a series of given genes (specified in the argument `genes`), or, alternatively, the location of detected CNVs (argument `mark.detected.cnv = T`)


```{r, include=TRUE, eval=FALSE}
col_fun <- circlize::colorRamp2(seq(-0.2, 0.2, length.out = 11), rev(pals::brewer.rdylbu(11)))
heatmap_CNV(scMuffinList = scMuffinList_demo, genes = c("YBX1", "HNRNPM"), genes.labels = T, col=col_fun)

heatmap_CNV(scMuffinList = scMuffinList_demo, mark.detected.cnv = T, col=col_fun)

```

![caption](images/heatmap_CNV_PJ016_vignette_genes.jpg){width=600px}
![](images/heatmap_CNV_PJ016_vignette_cnv.jpg){width=600px}

To function `plot_profile_CNV` plots the median CNV profile of a cluster:

```{r, include=TRUE, eval=FALSE}
plot_profile_CNV(scMuffinList = scMuffinList_demo, cluster = 0, cex.points = 0.5) 
```
![](images/CNV_profile_ref_0.png_0.png){width=600px}

# Transcriptional complexity

The transcriptional complexity can be quantified by means of the function `transcr_compl`. The corresponding summary element contains a `data.frame` with the number of cell transcripts, the number of genes detected in every cell, the TC-ratio (C), the TC-LMR (linear model residual) and the TC-H (entropy):

```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- transcr_compl(scMuffinList_demo)
```
```{r, include=TRUE, eval=TRUE}
head(scMuffinList_demo$transcr_compl$summary)
```

# Cell proliferation rate

Cell proliferation is quantified considering the maximum between the two scores of G1/S and G2/M gene sets:
```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- proliferation_analysis(scMuffinList_demo)
```
The proliferation score is stored in the `summary` element of `scMuffinList_demo$proliferation`:
```{r, include=TRUE, eval=TRUE}
head(scMuffinList_demo$proliferation$summary)
```

# Cell state trajectories
Diffusion maps identify differentiation trajectories. scMuffin relies on the diffusion pseudo time calculation available in the R package "destiny" [@Angerer2016]. Here we calculate the diffusion map over the first 50 PC (to speed up computation), using a random cell to obtain diffusion pseudotimes:

```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- diff_map(scMuffinList_demo, root_cell = "random", n_pcs=50)
```
A data.frame with the most important features of the analysis (the first two eigenvectors, pseudotime, branch information and whether a cell is a tip of the branch or not) are stored `scMuffinList_demo$diffusion_map_pseudo_t$summary`:
```{r, include=TRUE, eval=TRUE}
scMuffinList_demo$diffusion_map_pseudo_t$summary
```

# Cluster enrichment assessment

Cell clusters can be assessed for enrichment in quantitative and categorical values. The appropriate statistical test is automatically chosen according to feature type. In this example, we assess cluster enrichment for the feature `gene_set_scoring` (quantitative one) for the cluster defined by the partition `global_expr`:
```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- assess_cluster_enrichment(scMuffinList_demo, feature_name = "gene_set_scoring", partition_id = "global_expr")
```
In case of quantitative features the result is a list named CSEA, placed under the elements `cluster_data$global_expr` (partition id). The list contains the gene set table and the leading edge results. Here's the result related to the gene set `CSEA_Angiogenesis`:
```{r, include=TRUE, eval=TRUE}
scMuffinList_demo$cluster_data$global_expr$CSEA$gs_table$CSEA_Angiogenesis
```
In this this example we assess cluster enrichment in relation to categorical feature, namely cell cycle phase:
```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- assess_cluster_enrichment(scMuffinList_demo, feature_name = "CC_Phase", partition_id = "global_expr")
```
As for categorical features the result is a list named ORA, placed under the elements `cluster_data$global_expr` (partition id). The list contains ORA results for every categorical value. Here's the enrichment of clusters in terms of cells with value "G1":
```{r, include=TRUE, eval=TRUE}
scMuffinList_demo$cluster_data$global_expr$ORA$CC_Phase$G1
```

The enrichment analysis results appearing in these tables can be easily extracted and organized in a clusters-by-values table by means of `extract_cluster_enrichment_table`. For instance, here we extract CSEA NES and FDRq values, and ORA er (enrichment ratio) values:

```{r, include=TRUE, eval=TRUE}
csea_fdr_table <- extract_cluster_enrichment_table(scMuffinList_demo,  partition_id = "global_expr", type = "CSEA", quantity = "FDRq")
csea_nes_table <- extract_cluster_enrichment_table(scMuffinList_demo,  partition_id = "global_expr", type = "CSEA", quantity = "nes")
ora_p_table <- extract_cluster_enrichment_table(scMuffinList_demo,  partition_id = "global_expr", type = "ORA", quantity = "p")
csea_fdr_table
```
These tables can be plotted with the function `plot_heatmap_features_by_clusters`. In the following example we plot NES values with a asterisks according to their significance:

```{r, include=TRUE, eval=FALSE}
plot_heatmap_features_by_clusters(feature_source = csea_nes_table, significance_matrix = csea_fdr_table, sig_threshold = 0.05)
```
![](images/nes.fdr.png){width=300px}

Similarly, it's possible to extract the most significant "tags" of any clusters; for example, here we extract the top 3 tags by FDRq (CSEA) and p_adj (ORA):
```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- extract_cluster_enrichment_tags(scMuffinList_demo, partition_id = "global_expr", n_max_per_cluster = 3, CSEA_selection_criterion="FDRq", only_pos_nes = TRUE, CSEA_selection_threshold = 0.05, ORA_selection_criterion = "p_adj", ORA_selection_threshold = 0.25)
```
The results are placed under the `cluster_tags` element:
```{r, include=TRUE, eval=TRUE}
head(scMuffinList_demo$cluster_data$global_expr$cluster_tags$CSEA)
```

The results of cluster enrichment can be visualized by barplots and boxplots for, respectively, categorical values and quantitative values.
```{r, include=TRUE, eval=FALSE}
barplot_cluster(scMuffinList_demo, partition_id = "global_expr", feature_name = "CC_Phase", feature_id = "CC_Phase")
boxplot_cluster(scMuffinList_demo, feature_name = "gene_set_scoring", partition_id = "global_expr")
```
![caption](images/cluster_2_barplot.jpg){width=600px}
 ![caption](images/cluster_2.jpg){width=600px}
 
# Comparison between clusters

## Intra-dataset

The function `overlap_matrix` calculates the overlap coefficient between all-pairs of clusters of two or more partitions of the same cells (same dataset):

```{r, include=TRUE, eval=FALSE}
scMuffinList_demo <- overlap_matrix(scMuffinList_demo)
```
The results are stored under the element `cluster_comparison```:
```{r, include=TRUE, eval=TRUE}
head(scMuffinList_demo$cluster_comparison$overlap_matrix)
```

## Inter-dataset

Inter-dataset comparison is performed through the function `inter_dataset_comparison`, which require a list of Seurat objects and a gene set list. The activity of this gene set list will be assessed over the clusters of all datasets. In needed, the function `prepare_cluster_markers_list` provides the possibility to prepare a gene set list of cluster markers, starting 

```{r, include=TRUE, eval=FALSE}
dataset_cmp_res <- inter_dataset_comparison(seu_obj_list = seu_obj_list, gsl = cluster_markers_list, genes_max = 500, genes_min = 5)
plot_heatmap_dataset_comparison(dataset_cmp_res, outfile = "vignette/heatmap_ds_cmp.png")
plot_heatmap_dataset_comparison(dataset_cmp_res, outfile = "vignette/heatmap_ds_cmp_p.png", type = "significance")
```
![caption](images/heatmap_ds_cmp.png){width=600px}
![caption](images/heatmap_ds_cmp_p.png){width=600px}

The function can be used to analyze any gene set. In the following example we assess the expression of CancerSEA gene sets across datasets:

```{r, include=TRUE, eval=FALSE}
gsl <- prepare_gsls(gs_sources = "CancerSEA", genes=unlist(lapply(seu_obj_list, rownames)))
dataset_cmp_res_cancersea <- inter_dataset_comparison(seu_obj_list = seu_obj_list, gsl = gsl$CancerSEA, genes_max = 500, genes_min = 5)
plot_heatmap_dataset_comparison(dataset_cmp_res_cancersea, outfile = "vignette/heatmap_ds_cmp_cancer.png")
```
![caption](images/heatmap_ds_cmp_cancer.png){width=600px}

# References

<!-- ## Comparison of partitions and definition of meta-clusters

Lastly, scMuffin provides some functions to compare 

```{r, include=TRUE, eval=FALSE}
cl_list <- partitions_to_list(partitions = clust_obj)
ov_mat <- overlap_matrix(cl_list)
meta_cl <- meta_cluster(ov_mat, n_step = 10, max_clust = 15)
meta_cl_cell <- get_meta_clusters(cl_list, meta_cl)
plot_meta_clusters(ov_mat, meta_clusters = meta_cl)
```
-->